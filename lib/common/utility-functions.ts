import { BadRequestException, HttpException, HttpExceptionBodyMessage, HttpStatus, InternalServerErrorException, NotFoundException } from "@nestjs/common";
import { createReadStream, existsSync, mkdirSync, readFileSync, statSync, unlinkSync, writeFileSync } from "fs";
import { join } from "path";
import constants from "./constants";
import CryptoJS from 'crypto-js';

/**
 * Creates custom NestJS's HttpException
 * @param { Error | object } objectOrError Error object or JSON object for error details
 * @param { number } status HTTP status code
 * @param { string } description Exception description
 * 
 * @example
 *  throw new CustomException({
 *          success: false,
 *          message: "Item not found"
 *      },
 *      418,
 *      "Item was not found"
 *  );
 */
export class CustomException extends HttpException {
    constructor(objectOrError: Error | object, status: number, description: string = '') {
        super(HttpException.createBody(objectOrError as HttpExceptionBodyMessage, description, status), status);
    }
}

/**
 * Function to encrypt a string using a predefined secret key
 * @param {string} value Value to be encrypted
 * @returns {string} An encrypted string
 */
export const cryptoAES = (value: string): string => {
    return CryptoJS.AES.encrypt(value, process.env.JWT_SECRET || constants.JWT_SECRET || 'some secret').toString();
}

/**
 * Compares the hash generated by cryptoAES() and a plain text.
 * @param {string} value Plain text value to compare
 * @param {string} hash Encrypted text value to compare
 * @returns {boolean} returns `true` if hash of the provided value and provided hash matches.
 */
cryptoAES.compare = (value: string, hash: string) => {
    return CryptoJS.AES.encrypt(value, process.env.JWT_SECRET || constants.JWT_SECRET || 'some secret').toString() === hash;
}

/**
 * It will create the path directory
 * @param {string} dir Directory path to be created
 * @returns {boolean} Returns `true` if path exists or created successfully, or false in case of any error
 */
export const createPath = (dir: string): boolean => {
    try {
        if (existsSync(dir)) return true;
        else {
            mkdirSync(dir, { recursive: true });
            return true;
        }
    } catch (e) {
        console.error(e);
        return false;
    }
}

/**
 * This function will save the a single file to disk
 * @param dir Directory path where to store the file
 * @param file Express.Multer.File Object which has to be saved to provided directory path
 * @param fileName File name to be used to save the file
 * @returns Returns boolean value `true` if files is saved successfully, else `false`.
 */
export const saveFileToDisk = (dir: string, file: Express.Multer.File, fileName: string) => {
    try {
        createPath(dir) && writeFileSync(join(dir, fileName || file.originalname || ""), file.buffer);
        return true;
    } catch (e) {
        console.error(e);
        return false;
    }
}
/**
 * Return boolean true if file doesn't exists on given path
 * @param path Path to the file need to be deleted
 * @returns {boolean} Return false if files exists.
 */
export const deleteFileFromDisk = (path: string) => {
    try {
        if (existsSync(path) && statSync(path).isFile()) {
            unlinkSync(path);
        }
    } catch (e) {
        console.error(e);
        return !existsSync(path);
    }
    return !existsSync(path);
}
/**
 * Return an object containing file object or error object along with a flag named `success`.
 * @param filePath File directory path
 * @param throwError `true` will throw network error, `false` will give error
 * @returns {{}}
 */
export const importFile = (filePath: string, throwError = false) => {
    try {
        let file = readFileSync(filePath);
        return {
            file,
            success: true
        };
    } catch (e) {
        console.error(e);
        if (throwError) {
            switch (e.name) {
                case 'ENOENT': throw new CustomException({ message: "File not found", success: false }, HttpStatus.NOT_FOUND);
                default: {
                    console.log("Error Name: " + e.name);
                    throw new CustomException({ message: "Unknown error", success: false }, HttpStatus.INTERNAL_SERVER_ERROR);
                }
            }
        }
        return {
            error: e,
            success: false
        }
    }
}
export const serveReadStream = (res: any, path: string) => {
    if (existsSync(path)) {
        try {
            const file = createReadStream(path);
            return file.pipe(res);
        } catch (e) {
            console.log(e.name)
            if (e.name === 'ENOENT') {
                throw new BadRequestException();
            } else {
                throw new InternalServerErrorException();
            }
        }
    }
    throw new NotFoundException();
}

export const isSame = (a: any, b: any) => {
    if (a === b) return true;
    else if (typeof a === typeof b) {
        if (['string', 'number'].includes(typeof a)) return a === b;
        if (Array.isArray(a) && Array.isArray(b)) return a.length === b.length && !a.some((p, i) => !isSame(p, b[i]));
        if (({}).constructor === a.constructor && ({}).constructor === b.constructor)
            return !Object.keys(a).some(key => !isSame(a[key], b[key])) && !Object.keys(b).some(key => !isSame(a[key], b[key]))
    }
    return false;
}

export const difference = (
    left: any[],
    right: any[],
    compareFunction: (a: any, b: any) => boolean = isSame
) => {
    if (Array.isArray(left) && Array.isArray(right))
        return left.filter(leftValue =>
            !right.some(rightValue =>
                compareFunction(leftValue, rightValue)));
    else if (({}).constructor === left.constructor && ({}).constructor === right.constructor) {
        let _left = JSON.parse(JSON.stringify(left))
        return Object.keys(left).reduce((prev, curr) => {
            try {
                delete prev[curr];
            } catch (e) {
                
            }
            return prev;
        },_left)            
    }
}
